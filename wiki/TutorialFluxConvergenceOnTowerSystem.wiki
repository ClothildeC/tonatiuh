#summary One-sentence summary of this page.

= Introduction =

 * The main aim of this tutorial is explain how to analyze the tonatiuh output data to stimate the flux distribution on the target.


= Characteristics of the system =

The system we want to simulate consists of:

 * A tower.
 * One heliostat.
 * A flat plane as a receiver.

=General aspects of the system =

The system we are going to simulate is made up of a flat square of 15 x 15 meters located on the top of a cylindric tower of 150 meters heigth.
400 meters away of the tower, we are going to create a flat square with a surface of 60 m<sup>2</sup> . This flate rectangle called Heliostat is going to with an inclination of 45º compared to the ground.
We are asumming that the solar concentrating system is placed in Sevilla, Spain at 11.00 A.M.
 
= Modeling the system =

== Modeling the tower ==
 * Once tonatiuh is opened, we have to select the rootNode and, then, add a TSeparator as a childen. The TSeparator node is the blue circular buttom allocated on the icon bar.
 * When the node is created, rename it to "Tower". With this new node selected, create a new TSeparator as a node child and rename it to "Base".
 * If we select the "Base" node,we can add one shape on it. Only if we create first a TShapeKit node (the red circle icon next to the blue one), we will be able to insert a shape.
 * With the TShape node, previously created, selected, we can add a shape. In this case, we are using a cylinder shape called Cylinder. We can find it on the plugin menu bar.
 * Once the cylinder is created, select it and change their values to those ones:
{{{
radious        15
length         120
phiMax         6.2831855
activeSide     OUTSIDE
}}}
 * Now, it is time to create the target. Select the node "Tower" and create a new TSeparator. Rename it to "Target". Change it transform values to:
{{{
translation        0 100 0
rotation           0 1 0 1.5707964
scaleFactor        1 1 1 
scaleOrientation   0 0 1 0 
center             0 0 0 
}}}

 * Select the new node and add a new TSeparatorKit as a child. Rename it to "target" and change the parameters to:
{{{

rotation           0 0 -1 1.5707964
scaleFactor        1 1 1 
scaleOrientation   0 0 1 0 
center             0 0 0 
}}}
 * Add a new TShapeKit as a child of the last node created.Now add a new shape as a child.In this example, the shape must be a "flat_rectangle". If we have created it properly, it should be visible on the 3D scene viewer.
 * Set those parameters on the "flat_rectangle" options:
 {{{
width        15
heigth       15
activeSide   FRONT
 }}}
 * Select the last TShapekit created and add a "specular_standar_material" as a child. 


== Modeling the heliostat ==

By this moment, the tower of the system has been created. Now we need to create the heliostat. According to the initial conditions, the heliostat must be situated 400 meters away the tower with an inclination of 45º. To create it, follow those steps:
 * Select the rootNode and create TSeparator node by clicking on the "Group Node" icon. Rename it to "heliostat". We want the heliostat with an inclination of 45º and 400 metres away the tower. To fix the heliostat on the correct point we need to know the values for x and z. For x we have to calculate cos(45º) x 400. For z we have to calculate sen(45º) x 400. now we have to set them on the "helioStat" transform parameters in that way:
{{{
translation    282.85 0 282.85
 }}}

 * Select "Heliostat" and add a new TSeparator. Rename it to 
"heliostatSurface".

 * Select the last node created and add a Traker (the last icon on the rigth icon bar). In the transform options,change the aimingPoint to:
 {{{
aimingPoint   0 100 0
 }}}
 The main property of this element is to make the heliostat change the position  while the sun is moving. Doing that, we can project more rays from the sun to to the target.
 * Select the "heliostatSurface" node and add a TShapeKit node.
 * Now, add a "flat-rectangle" shape and a "specular_Standar_material" as a child on the previous TShapeKit.
 * We want a square flat which surface of with a surface of 60 m<sup>2</sup>. So we have to set it values to:
 {{{
width         7.7399998
heigth        7.7399998
activeSide    FRONT
 }}}
If we have done all steps successfully, we are about to run the system.

== Running the system ==

The main purpose of Tonatiuh is to get information about how rays can reach the target. We can simulate the rays in two ways: 
 * The easiest one consists of pressing the run button in the icon bar. You only obtain one photon map for each interaction. To expoer the pohoton map press Ray Trace, export photmmap.


 * The other is using the script editor.You can obtain it pressing Automation -->script editor. This will display a new window. A basic script can be like this:
{{{
//load the file
tonatiuh_filename( "HeliostatSunSevilla.tnh" ); 
//number of rays to simulate
tonatiuh_numrays( 1000000  ); 

//type of phton map
tonatiuh_photon_map("PhotonMapDefault"); 
//type of random
tonatiuh_random_generator("Mersenne Twister"); 
//patch of the target
var concentratorSurface = "//RootNode/Tower/Target/Target/Target"; 
//output folder/name of file to export. create the folder previously
var concentratorFileName = "folder/filename"; 

//number of interactions
for( var i = 1; i <= 400; ++i ){ 
	tonatiuh_trace(); //simulate the system
	var s = i.toString();
//export the photon map data
	tonatiuh_export(  concentratorFileName.concat( "_", s, ".dat" ),  concentratorSurface, false );
}
}}}
 The results in that case are saved automatically into the folder we have defined in concentratorFileName variable.

= Tonatiuh post-processing =

Tonatiuh doesn't provide a photon map results analizer so it's necessary to use an external aplication such as Mathematica and R. The output photon map is saved in a .dat extension in a seven-tuple for each photon.

== Data post-processing with Mathematica ==
 We use mathematica to know when the photon maps converge. when we compare the convergence two by two, we get the relative error. if this error reaches a value lower than 0.5% in at least 5 cases, we will admit the result.

   === How to create a post-proccess script using Mathematica ===
   The following steps explain how we can make a script in Mathematica to read photons properly. Inthis case the tager was a square flat plane: 
 * First set the way Mathematica has to read the data and how to transform the coordinate to the target we are using currently. In this case we only need x and z to create a flat plane.
{{{
ReadTonatiuhResults[filename_] :=  BinaryReadList[ filename, "Real64", ByteOrdering -> +1];
transform01[{x_, y_, z_}] := { x , z }
}}}
 * Select the width and the heigth of the flat plane and calculate the area:
{{{
absorberLength = 15
absorberWidth = 15
absorberArea = absorberLength*absorberWidth
}}}
 *Define the number of cells in which the target is divided up. The more number you put, the more number of rays need simulating to reach the goal.
{{{
widthDivisions = 50;
lengthDivisions = 50;
}}}
 * We have to set the workspace of mathematica in the directory we have the data. First create the Notebook in this directory and set the directory with
{{{
SetDirectory[NotebookDirectory[]]
}}}
 * Search the folder in the current directory (DirectoryQ)where we have the .dat files.
{{{
directoryList = Select[FileNames["*"], DirectoryQ]
}}}
 * Get all the .dat files allocates in the directory (directoryList[[i]]. i is folder of the directorylist we are going to use) found in the previous step. 
{{
fileList = FileNames["*.dat", directoryList[[1]]];
}}
 * Once we have got all the files, we have to get their photons.
{{{
binsFilesList = Map[FluxMatrix, fileList];
}}}
This instruction applies the FluxMatrix function in all files of the directory.
FluxMatrix convert the .dat file to a .txt file. The .txt file has as many columns and files as the number of lengthDivisions and widthDivisions we have set and the haver the number of rays in the target in this cell.
{{{
FluxMatrix[fileName_] := 
 Module[{data, powerPerPhoton, photonsData2D, totalPhotons, totalPowerAtAbsorberTube, radialElementLength, 
        longitudinalElementLength, photonCounts, elementArea, fluxConversionFactor,
        incidentFluxMatrix, minimumFlux, maximumFlux,zmin, zmax, contourLevels, tonatiuhContour},


  data = ReadTonatiuhResults[fileName]; (*read file data*)
  powerPerPhoton = data[[1]]
  data = Drop[data, 1];
  (*read the seven-tuplas photon info*)
  (*[[5]]-->0 read back rays; [[5]]--> read front rays; none-->read all rays*)
  data = Select[Partition[data, 7], #[[5]] == 1 &] /. {id_, x_, y_, z_,side_, next_, prev_} -> {x, y, z};

  (*get the area*)
  data = Map[transform01, data];

  (*number of photons*)
   totalPhotons = Length[data];

  (*average power per photon*)
  totalPowerAtAbsorberTube = (totalPhotons * powerPerPhoton)/1000 (* kW *);

  (*cell width*)
  ElementWidth = absorberWidth  /widthDivisions (* meters *);

  (*cell length*)
  ElementLength = absorberLength/lengthDivisions (* meters *);

  (*put the photon in the corresponding cell *)
  photonCounts = BinCounts[data, {-absorberWidth/2, absorberWidth/2, radialElementLength}, 
                                 {-absorberLength/2, absorberLength/2, longitudinalElementLength}
     ];

  (*create and export *bins.txt files with the rays*)
  Export[StringJoin[DirectoryName[fileName], FileBaseName[fileName], "bins.txt"], photonCounts, "Table"]]
}}}

 * Now, we have to mix the element in the variable binsFileList to create a table with the simulation files. The first element of this new table only contains the first element of the table binsFileList;the second element contains the first an the second element of binsFilelist;the last element of this new table will contain all the files of the table binsFileList. 
{{{
simulationsFiles = Table[{ binsFilesList[[1 ;; i]], i}, {i, 1, Lengt[binsFilesList]}] ;
}}}
  Each element of simulationFiles is made whit two elements.The first one is a table of files and the second one is the number of elements on the first element.

 * Using the funtion PositionFluxMatrix, we will create the simulation files with the elemnts of the table simulationFiles.
{{{
simulationsBinsFiles = Map[PositionFluxMatrix[#[[1]], #[[2]]] &, simulationsFiles] ;
}}}
In the function PositionFluxMatrix, which has two parametes(the first one is the list, and the second is the number of elements in the list),create a new file by adding the elements of the file list all together. So, finally, the first simulation file will be compounded with the first "bins.txt" files; the secnd with the first and the second file;the last simulation file will contain the addition of all the bins files.

To make it easier in case you have lots of photon map files, you can do a parallel simulation. Instead of the last step, we have to use the following ones:
{{{
LaunchKernels[]
DistributeDefinitions["Global`"]
simulationsBinsFiles = ParallelMap[PositionFluxMatrix[#[[1]], #[[2]]] &, simulationsFiles] ;
}}}
*Note:This only will work of the computer have more than one core. If it not your case, you will not be able to use this step.

 * From this point, we can start to proccess the simulation files we have created to get results. The first thing is to load all the sun data such as irradiance,surface and number of photons per simulation:
{{{
irradiance = 1000; 
nPhotons = 5000000;
(*sun area *)
xMin = -23.74863394708676;
xMax = 307.1679263970379;
zMin = -113.2988162896161;
zMax = 208.1505313775067;
inputArea = (xMax - xMin)*(zMax - zMin);
}}}
*The value of xMin, xMax, zMin, zMax we need to calculate the sun area are only visible by opening the .tnh file we are simulating and looking for them in the file. This step is very important because the sun shape changes from one system to another!*
  * For each simulationBinFiles, calculate the power per photon.
{{{
wPhotons = Table[irradiance* inputArea/(nPhotons*i), {i, 1, Length[simulationsBinsFiles]}] // N ;
}}}
 * To see if the results are good or not,we have to get the relative error:
{{{
 errorFluxMax = Table[100*(results[[i, 5]] - results[[i - 1, 5]])/results[[i 1, 5]], {i, 2, Length[results]}]
}}}
*The simulation will be a success if the relative error result is lower than 0.5 in, at least, 5 consecutive cases.

 * We can plot and get a graphical file of the results of the realtive error by typing:
{{{
rel = ListPlot[errorFluxMax, Joined -> True, 
  LabelStyle -> Directive["Helvetica", 14], AxesLabel -> {"Millions of Rays"}, 
  PlotRange -> {All, {-100, 100}}  , ImageSize -> {1000, 600}]

Export["TargetMFlux_error.png", rel]
}}}
 * Another interesting result migth be how the maximun flux is going. To know that, type:
{{{
fluxMax = Table[results[[i, 5]], {i, 1, Length[results] }];
flux= ListPlot[fluxMax, Joined -> True, 
  LabelStyle -> Directive["Helvetica", 14], 
  AxesLabel -> {"Millions of Rays", 
    "Maximum flux(kW/\!\(\*SuperscriptBox[\(m\), \(2\)]\))"}, 
  PlotStyle -> Thickness[0.007], PlotRange -> {All, {0, 10}} , 
  ImageSize -> {1000, 600}]

Export["TargetMaximumFlux.png", flux]
}}}

 * If you want to see graphically haw the flux distribution is going, you can use this:

{{{
results = Table[fluxAnalysis[{simulationsBinsFiles[[i]],wPhotons[[i]]}],{i, 1, Length[simulationsBinsFiles]}];
}}}

This is a basic tonatiuh data proccesing